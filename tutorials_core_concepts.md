% Core concepts of GNU Radio
% Author: GNU Radio contributors
% Translator: Yoon Kyong Lok(steveyoon@telechips.com)

# <a name="core-concepts"></a>Core Concepts of GNU Radio

이 문서는 GNU Radio의 매우 기초적인 입문 튜토리얼 입니다. 여러분은 다른 것을 보기 전에 이 문서를 확실히 읽으셔야 합니다. 여기에서 다루는 모든 걸 전에 들었을지라도 적어도 놓치는 것이 있는지 한번 훑어 보셔야만 합니다.

## <a name="flow-graphs-and-what-theyre-made-of"></a>Flow graphs -- and what they're made of

어딘가로 가기 전에, 먼저 우리는 GNU Radio에 대해서 가장 기초적인 개념(흐름 그래프와 블록들)을 이해해야 합니다.

흐름 그래프는 데이터 흐름들을 통과하는 그래프([graph theory](http://en.wikipedia.org/wiki/Graph_Theory)에 따르는)입니다. 많은 GNU Radio 응용 프로그램들은 흐름 그래프 말고 다른 것은 포함하고 있지 않습니다. 그래프와 같은 노드들을 *블록들(blocks)*이라고 부르고 데이터는 그 끄트머리~edges~를 따라 흐릅니다.

어떤 실제 신호 처리 기능도 블록으로 완성됩니다. 이상적으로, 모든 블록은 정확히 하나의 일을 합니다 \- 이 방식으로 GNU Radio의 모듈성과 융통성이 유지됩니다. 블록들은 대게 C++(아마 파이썬으로도)로 작성됩니다. 그리고 [새로운 블록을 만드는 것](http://gnuradio.org/redmine/projects/gnuradio/wiki/OutOfTreeModules)이 아주 어렵지는 않습니다.

이 조금 산만한 주제를 명확히 하기 위해, 예제 하나를 시작하겠습니다. (이 모든 예제는 GNU Radio의 GUI인 [GNU Radio Companion (GRC)](http://gnuradio.org/redmine/projects/gnuradio/wiki/GNURadioCompanion)로 만들어졌습니다.)

여기, 세 개의 블록들(사각형들)이 있습니다. 이 예제에서 데이터는 왼쪽에서 오른쪽으로 흘러 갑니다. 그것은 오디오 쏘스에서 시작하여 로우 패쓰 필터를 통과하고 하드 디스크 파일로 쓰여지면서 끝나는 것을 의미하고 있습니다.

![첫번째 예제](http://gnuradio.org/redmine/attachments/download/406/fg1-audiolpf.png)\

블록들은 *포트~ports~*로 연결됩니다. 첫번째 블록은 입력 포트가 없고 샘플들을 만들어 냅니다. 오직 출력 포트만 가지고 있는 블록을 *쏘스~source~*라고 합니다. 아날로그 관습으로 출력이 없는 마지막 블록은 *싱크~sink~*라고 합니다.

때때로 혼란스러운게, 사용자 관점에서 오디오 블록은 사운드 카드에서 오디오 샘플을 얻어오므로 바로 처리의 한 부분이라는 겁니다. 하지만 우리가 싱크와 쏘스를 말할 때, 항상 흐름 그래프의 관점에서 이야기 합니다. [^1]

[^1]: 흐름 그래프는 싱크, 쏘스, 처리 블록으로 이루어지는 데 첫번째 예제에서 쏘스가 사운드 카드에서 오디오를 입력 받아서 샘플을 출력 하므로 처리 블록일 것 같지만, 흐름 그래프 관점에서는 사운드 카드가 없으므로 쏘스 블록으로 항상 얘기한다는 말입니다.

그래서 여기에서 무슨 일이 벌어질까요. 오디오 쏘스 블록은 사운드 카드 드라이버와 연결되고 오디오 샘플들을 출력합니다. 이 샘플들은 로우 패쓰 필터에 연결되고 로우 패스 필터는 샘플들을 더 처리합니다. 마지막으로 샘플들은 WAV 파일로 쓰여지는 블록으로 전달됩니다.

## <a name="items"></a>Items

일반적으로 우리는 블록의 출력으로 어떤 아이템이든 호출할 수 있습니다. 이전 예제에서 하나의 아이템은 오디오 드라이버에서 만들어진 하나의 샘플을 표현하는 부동소수점 값이었습니다. 그러나 아이템은 디지털 방식으로 표현될 수 있는 어떤 것이라도 될 수 있습니다. 샘플들의 가장 일반적인 데이터형은 실수 샘플들 \(앞의 예처럼\), 복소수 샘플들 \(Software defined radio에서 가장 일반적인 데이터형\), 정수 데이터형, 그리고 이들 스칼라 데이터형들의 벡터들이 있습니다. 

이 이후의 개념을 이해하기 위해, FFT 분석을 생각해 보겠습니다. 우리가 신호를 파일로 저장하기 전에 FFT를 수행하려고 한다고 해보겠습니다. 물론 우리는 FFT를 계산하는 시점에 확실한 수의 샘플들이 필요합니다 그리고 FFT는 필터와는 다르게 샘플 단위로 동작하지 않습니다.

![두번째 예제](http://gnuradio.org/redmine/attachments/download/427/fg2-fftvec.png)\

여기에 \'스트림에서 벡터로\(Stream to Vector\)\'라는 새로운 블록이 있습니다. 이것의 특별한 점은 입력 데이터형과 출력 데이터형이 다르다는 것 입니다. 이 블록은 1024 샘플들\(즉, 1024개의 아이템\)을 가져와서 그것들을 1024 샘플의 벡터 하나\(하나의 아이템\)로 출력합니다. 복소수 FFT 출력들은 복소수의 2승으로 변환되고 그것은 실수 데이터형입니다. \(우리가 포트마다 서로 다른 데이터형을 지시하기 위해 어떻게 서로 다른 색을 사용했는지 보십시오.\)

그러니까 아이템은 샘플, 비트 묶음, 필터 계수 세트, 또는 무엇이든 될 수 있다는 것을 기억하십시오.

### <a name="summary1"></a>Summary

지금까지 배운 것 중 여러분이 반드시 알아야 하는 것은 다음과 같습니다.

* GNU Radio의 모든 신호 처리는 흐름 그래프를 통해 이루어집니다.
* 흐름 그래프는 블록들로 구성됩니다. 블록은 필터링, 신호 추가, 변환, 디코딩, 하드웨어 접근 등과 같이 많은 것들 중 하나의 신호 처리 운용을 수행합니다.
* 데이터는 복소수나 실수 정수, 부동소수점 수나, 기본적으로 여러분이 정의할 수 있는 어떤 종류의 데이터형이든 다양한 형식으로 블록들 사이에 통과됩니다.
* 모든 흐름 그래프는 적어도 하나의 싱크와 쏘스를 필요로 합니다.

## <a name="so-what-does-gnu-radio-do"></a>So what does GNU Radio do?

첫번째, 여러분이 할 것은 흐름 그래프를 설계하고, 블록을 선택하고, 연결을 정의하고, 이 모든 것을 GNU Radio에 이야기 하는 것 입니다. GNU Radio는 여기에서 두 번 사용됩니다. 첫째로 많은 블록들을 여러분에게 제공해줍니다. 둘째로, 일단 흐름 그래프가 정의된다면, 하나씩 잇따라 블록들을 호출함으로써 그 흐름 그래프를 실행시키고 아이템이 한 블록에서 다른 블록으로 통과되는 것을 확인합니다.

## <a name="sampling-rates"></a>Sampling rates

물론, 여러분이 이것을 읽고 있다는 것은 여러분은 이미 샘플레이트가 무엇인지 알고 있다는 것일 겁니다. \(아니라면, 얼른 공부하고 오십시오.\)  샘플레이트가 흐름그래프와 어떻게 관련되는지 한 번 보겠습니다. 첫번째 예제에서, 오디오 쏘스는 32ksps[^2]의 고정된 샘플레이트를 가지고 있습니다. 필터가 샘플레이트를 바꾸지 않기 때문에 샘플레이트는 전체 흐름그래프에서 사용됩니다.

[^2]: 오타가 아닙니다. sample per second로 보입니다. 

두번째 예제에서, 두번째 블록\(stream to vector\)은 매 1024 입력 아이템마다 하나의 아이템을 생산합니다. 그래서, 아이템을 생산하는 곳의 비율이 아이템을 소비하는 곳의 비율보다 1024배 작습니다. \(실제로 생산하는 바이트가 소비되는 것과 같은 비율을 갖는다는 사실은 여기에서 무의미합니다.\) 그와 같이 블록을 *학살자~decimator~*라고 부릅니다. 음, 왜냐하면 그것이 아이템 비율을 학살하니까요.[^3]

[^3]: 번역하는 저도 소름이 끼쳤습니다.
