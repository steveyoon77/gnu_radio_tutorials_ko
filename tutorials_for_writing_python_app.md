# <a name="Introduction"></a>Introduction
  GNU Radio 초보자 여러분 환영합니다. 이 튜토리얼을 읽으시는 여러분은 아마 GNU Radio가 어떻게 동작하는지, 그게 무엇이고 무엇을 할 수 있는지에 대해서 다소 기초적인 지식을  이미 알고 있을 것 입니다. 그리고 이제 여러분 스스로 환상적인 오픈 소스 디지털 신호처리의 세계에 들어가길 원할 겁니다.
  이 튜토리얼은 GNU Radio 3.7 버전을 이용하여 어떻게 Python으로 GNU Radio application을 작성하는지에 대한 것 입니다. 프로그래밍이나, 소프트웨어 라디오, 신호처리에 대한 것이 아니라, 새로운 블록을 추가하거나 소스 트리에 코드를 추가하여 GNU Radio를 어떻게 확장할지에 대한 것입니다. 여러분이 저런 주제(프로그래밍, 소프트웨어 라디오나 신호처리)에 대해 백그라운드를 가지고 계시고 GNU Radio로 작업을 시작했다면 이것은 아마 여러분에게 올바른 튜토리얼일 것 입니다. 여러분이 소프트웨어 라디오에 대해서 잘 모르신다거나 FIR filter가 무엇을 하는지 잘 모르신다면 여러분은 먼저 신호처리 이론에 대해서 견고한 백그라운드를 습득하셔야 할 것 입니다. 무엇인가를 배우는 가장 좋은 길은 해보는 것 입니다.
  비록 이 튜토리얼이 여러분에게 GNU Radio에 대해서 가능한 쉽게 소개하려고 디자인됐지만, 완벽한 가이드는 아닐 겁니다. 사실, 저는 때때로 단순히 더 쉽게 설명하기 위해 진실을 말하지 않을 것 입니다. 저는 또 이후의 챕터들에서 스스로에게 모순된 말을 할 것 입니다. GNU Radio application들을 개발하기 위해서는 여전히 머리를 좀 쓰셔야 할 것 입니다.

# <a name="Preliminaries"></a>Preliminaries
  이 튜토리얼을 시작하기 전에 GNU Radio가 설치되어 동작하는지 확인하십시오. USRP는 반드시 필요하지 않지만, 어떤 종류의 소스(입력원)과 sink (USRP, 오디오나 다른 하드웨어)가, 비록 엄격히 요구되는건 아니지만, 도움이 될 것입니다. GNU Radio 예제들(gr-audio/examples/python 안의 dial_tone.py과 같은)이 동작한다면 시작할 준비가 되신 것 입니다.
  여러분은 프로그래밍에 대한 백그라운드를 가지고 있어야 합니다. 하지만 여러분이 파이썬으로 프로그램을 해본적이 없더라도 걱정하지 마십시오. 파이썬은 배우기에 매우 쉬운 언어입니다.

# <a name="Understanding-flow-graphs"></a>Understanding flow graphs
  우리는 코드를 폭발적으로 작성하기 전에 먼저 GNU Radio에 대한 가장 기본적인 개념(그래프 이론에 따르는 흐름 그래프와 블록들)을 이해할 필요가 있습니다. 많은 GNU Radio application들은 흐름 그래프 외엔 아무것도 포함하고 있지 않습니다. 이런 그래프의 노드들을 블록들이라고 부르고 데이터는 그 경계를 따라 흐릅니다.
  어떤 실제 신호 처리는 블록으로 완성됩니다. 이상적으로 모든 블록은 정확히 하나의 작업을 수행합니다. - 이 방법으로, GNU Radio는 모듈화 되고 유연하게 유지됩니다. 블록들은 C++로 작성되는데 새로운 블록을 작성하는 것은 매우 어렵지는 않지만 다른 곳에서 설명됩니다.

  블록들 사이를 통과하는 데이터는 모든 종류들(실제로 여러분이 C++에서 정의할 수 있는 모든 데이터형) 일 수 있습니다. 사실상, 하나의 블록에서 다음 블록으로 통과되는 가장 오랜 시간동안 샘플과 비트가 될 데이터로서 가장 흔한 데이터형들은 복소수와 실수, short 또는 long형 정수, 그리고 부동소수점형 값 입니다.

## <a name="Examples"></a>Examples
  이 산만한 주제를 조금 명확히 하기 위해, 몇 개의 예제를 시작해 봅시다.

### <a name="Low-pass-filtered-audio-recorder"></a>Low-pass filtered audio recorder

    +-----+  +-----+  +----------------+
    | Mic +--+ LPF +--+ Record to file |
    +-----+  +-----+  +----------------+

  첫번째로, 마이크에서 어떤 오디오 신호가 여러분 PC의 사운드 카드에 의해 녹음되고 디지털 신호로 변환됩니다. 그 샘플들은 어떤 FIR filter와 같은 것으로 구현된 low pass filter(LPF)인 다음 블록으로 스트림 됩니다. 그 필터된 신호는 필터된 오디오 신호를 파일로 저장하는 마지막 블록으로 전달됩니다.
  이 예제는 단순하지만 완전한 흐름 그래프입니다. 첫번째와 마지막 블록은 특별한 목적을 제공합니다: 그것들은 소스(입력원)과 싱크로서 운영됩니다. 모든 흐름 그래프는 적어도 하나의 기능하는 소스(입력원)과 싱크를 필요로 합니다.

### <a name="Dial-tone-generator"></a>Dial tone generator

    +------------------------+
    | Sine generator (350Hz) +---+
    +------------------------+   |   +------------+
                                 +---+            |
                                     | Audio sink |
                                 +---+            |
    +------------------------+   |   +------------+
    | Sine generator (440Hz) +---+
    +------------------------+

  이 간단한 예제는 종종 "Hello World of GNU Radio"라고 불립니다. 첫번째 예제와 달리, 두 개의 소스(입력원)를 가지고 있습니다. 반면에 싱크는 두 개의 입력(이 경우는 사운드 카드의 왼쪽과 오른쪽 채널)을 가지고 있습니다. 이 예제의 소스코드는 gr-audio/examples/python/dial_tone.py에 있습니다.

### <a name="QPSK-Demodulator"></a>QPSK Demodulator

    +-------------+  +----------------+  +------------------+
    | USRP Source +--+ Frequency sync +--+ Matched filter   |
    +-------------+  +----------------+  +-----------+------+
                                                     |           COMPLEX SAMPLES
                                       +-------------+------+
                                       | Symbol demodulator |
                                       +-------------+------+
                                                     |           COMPLEX SYMBOLS
    +-----------------+  +-----------------+  +------+------+
    | Source decoder  +--+ Channel decoder +--+ Bit mapping |
    +--------+--------+  +-----------------+  +-------------+
             |                                                   BITS
    +--------+--------+
    | Application     |                                          DATA
    +-----------------+

  이 예제는 조금 더 복잡합니다. 하지만 RF 엔지니어에게는 꽤 익숙할 것 입니다. 이 경우는 소스가 하나의 안테나에 연결된 USRP 입니다. 이런 종류의 소스는 복소수 샘플들을 이어지는 블록에 보냅니다.

  이런 종류의 흐름 그래프에서 흥미로운 부분은 흐름 그래프 동안 데이터 형들이 변한다는 것입니다: 첫번째에서 복소수 베이스밴드 샘플들이 통과됩니다. 그러면 복소수 심볼들이 신호로부터 모여집니다. 다음에는 이 심볼들이 다음 번 처리를 위해 비트로 변환됩니다. 마지막으로 디코딩 된 비트들은 그 데이터를 이용하는 어떤 응용으로 전달됩니다.

### <a name="Walkie-Talkie"></a>Walkie Talkie

    +--------------+  +------------------+  +---------+  +------------+
    | USRP Source  +--+ NBFM Demodulator +--+ Squelch +--+ Audio Sink |
    +--------------+  +------------------+  +---------+  +------------+
    +--------------+          +----------------+         +------------+
    | Audio Source +----------+ NBFM Modulator +---------+  USRP Sink |
    +--------------+          +----------------+         +------------+

  이 applicaiton은 두 개의 분리되고 서로 병렬로 동작하는 흐름 그래프들로 구성되어 있습니다. 그것들 중 하나는 Tx(송신) 경로로 다루어지고, 다른 하나는 Rx(수신) 경로로 다루어집니다. 이런 종류의 application은 하나가 동작될 때 다른 하나를 중지시키기 위해 흐름 그래프 외부에 추가적인 코드를 요구할 것 입니다. 두 흐름 그래프는 적어도 하나의 소스(입력원)와 싱크를 서로 간에 요구합니다. 여러분은 조금더 복잡하지만 gr-uhd/examples/python/usrp_nbfm_ptt.py에서 이것을 수행하는 GNU Radio application을 찾을 수 있습니다.

## <a name="Summary1"></a>Summary
  흐름 그래프에 대한 결론을 정리합니다. 여기에 여러분이 정말로 알아야만 하는 중대한 요점을 빠르게 요약합니다.

* GNU Radio에서 모든 신호처리는 흐름 그래프로 완성됩니다.
* 흐름 그래프는 블록들로 구성됩니다. 하나의 블록은 필터링, 신호 추가, 변환, 디코딩, 하드웨어 접근 외의 많은 동작들과 같은 신호처리 운용의 하나를 수행합니다.
* 데이터는 블록 간에 복소수, 실수 정수, 부동소수점 수, 또는 여러분이 정의할 수 있는 기본적인 데이터형 등의 다양한 형태로 전달됩니다.
* 모든 흐름 그래프는 적어도 하나의 싱크와 소스(입력원)를 필요로 합니다.

# <a name="A-first-working-code-example"></a>A first working code example

  다음 단계는 이런 흐름 그래프들을 실제 파이썬에서 어떻게 작성할 수 있는지 아는 것 입니다. 약간의 코드를 한 줄 한 줄 분석하는 것으로 시작해 보도록 하겠습니다. 여러분이 파이썬을 잘 알고 있다면 몇몇 설명은 아마 건너뛰어도 좋을 것 입니다만, 그렇지 않다면 아직 다음 절로 달려가시면 안됩니다. 이 설명은 파이썬과 GNU Radio 초보자 모두를 위한 것 입니다.
  아래의 코드 예제는 [Dial tone generator](#Dial-tone-generator)의 흐름 그래프를 표현한 것 입니다. 실제로 이것은 여러분이 gr-audio/examples/python/dial_tone.py에서 찾을 수 있는 코드 예제를 약간 수정한 버전입니다.

	#!/usr/bin/env python

	from gnuradio import gr
	from gnuradio import audio, analog

	class my_top_block(gr.top_block):
	    def __init__(self):
		gr.top_block.__init__(self)

		sample_rate = 32000
		ampl = 0.1

		src0 = analog.sig_source_f(sample_rate, analog.GR_SIN_WAVE, 350, ampl)
		src1 = analog.sig_source_f(sample_rate, analog.GR_SIN_WAVE, 440, ampl)
		dst = audio.sink(sample_rate, "")
		self.connect(src0, (dst, 0))
		self.connect(src1, (dst, 1))

	if __name__ == '__main__':
	    try:
		my_top_block().run()
	    except [[KeyboardInterrupt]]:
		pass

  첫번째 줄은 유닉스, 리눅스 백그라운드를 가진 분들이 보시기에 익숙합니다: 이것은 이 파일은 파이썬 파일이고 이 파일을 실행하기 위해 파이썬 번역기를 이용해야 한다고 알려주는 쉘 스크립트입니다. 이 파일이 명령줄에서 직접 실행되길 원하신다면 이 줄이 필요합니다.

  세번째, 네번째 줄은 GNU Radio를 실행하기 위해 필요한 파이썬 모듈을 포함 시킵니다. _import_ 명령은 C/C++에서 _#include_ 지시자와 비슷합니다. 여기, gnuradio에서 온 3개의 모듈이 추가되었습니다: gr, audio, 그리고 analog. 첫번째 모듈인 gr은 기본적인 GNU Radio 모듈입니다. 여러분은 GNU Radio application을 실행하기 위해 이것을 항상 포함시켜야만 합니다. 두번째 모듈은 [audio device block](http://gnuradio.org/doc/doxygen/page_audio.html)들을 불러오고, 세번째 모듈은 [analog signal functionality와 modulation](http://gnuradio.org/doc/doxygen/page_analog.html)을 포함시킵니다. 많은 GNU Radio 모듈들이 있고, 그 모듈들의 짧은 목록을 후에 정리하겠습니다.

  6번째 줄부터 17번째 줄까지는 또 다른 클래스인 gr.top_block으로부터 상속받은 my_top_block이라는 클래스를 정의합니다. 이 클래스는 기본적으로 흐름 그래프를 위한 컨테이너입니다. gr.top_block 클래스를 상속받음으로써, 여러분은 블록을 추가하고 그것들을 연결하기 위해 필요한 모든 hooks과 함수들을 얻을 수 있습니다.

  오직 한 멤버 함수만이 이 클래스에 정의되어 있습니다: _\_\_init\_\_()_는 이 클래스의 생성자입니다. 이 함수의 첫번째 줄에서(8번째 줄), 부호 생성자가 호출됩니다(파이썬에서, 이것은 명시적으로 요구됩니다. 파이썬의 대부분이 명시적으로 작성되도록 요구됩니다. 사실, 이것이 파이썬의 주요 원칙입니다.). 다음으로, 두개의 변수가 정의되었습니다: _sample\_rate_와 _ample_. 이들이 신호 생성기의 sampling rate와 amplitute를 제어할 것 입니다.

  다음 줄을 설명하기 전에, 이전 섹션에 세 개의 블록과 두 개의 경계로 구성된 흐름 그래프 차트를 보셨으면 합니다. 블록들은 13번째 줄부터 15번째 줄까지 정의되어 있습니다: 두 개의 [신호원](http://gnuradio.org/doc/doxygen/classgr_1_1analog_1_1sig__source__f.html)이 생성됩니다(_src0_과 _src1_). 이들 입력원은 주어진 주파수(350과 440Hz)와 주어진 sampling rate(32kHz)로 지속적으로 사인파를 생성합니다. 진폭은 _ampl_ 변수로 조절되고 0.1로 셋팅되었습니다. 블록 형 _analog.sig\_source\_f_의 접미사 "f"는 출력이 _float_이라는 것을 지시합니다. 이것은 오디오 싱크가 -1에서 1 사이의 범위에서 부동소수점 샘플을 허용하기 때문에 좋습니다. 이런 종류의 것들은 프로그래머가 주의해서 다루어야 합니다: 비록 GNU Radio가 연결이 올바른지 확인하지만, 수동으로 주의해서 다루어야 하는 것이 여전히 있습니다. 예를 들어, 여러분이 정수 샘플들을 _audio.sink_로 보내고 싶다면, GNU Radio는 에러를 낼 것 입니다. 하지만 여러분이 위의 예제에서 진폭을 1보다 큰 어떤 값으로 셋팅한다면 에러가 아닌 왜곡된 신호를 얻을 것 입니다.

  신호 싱크는 15번째 줄에 정의되어 있습니다: _audio.sink()_는 [soundcard control](http://gnuradio.org/doc/doxygen/classgr_1_1audio_1_1sink.html)로서 행동하며 그것에 어떤 샘플을 전송하여 재생하는 블록을 리턴합니다. 먼저 블록 안에서 비록 신호원에 의해 이미 셋팅되었더라도 sampling rate이 명시적으로 셋팅될 필요가 있습니다. GNU Radio는 (그것이 블록들 사이의 정보 흐름의 부분이 아니므로) 올바른 sampling rate를 문맥으로부터 추정할 수 없습니다.

  16번째와 17번째 줄은 블록들을 연결합니다. 블록들을 연결하는 일반적인 문법은 _self.connect(block1, block2, block3, ...)_입니다. 이것은 _block1_의 출력과 _block2_의 입력을 열견하고, _block2_의 출력과 _block3_의 입력을 연결하는 식으로 계속 연결합니다. 여러분은 _connect()_를 한 번 호출함으로써 여러분이 원하는 만큼의 block들을 연결할 수 있습니다. 여기, 우리는 _src0_와 _dst_의 첫번째 입력과 연결하고 _src1_과 _dst_의 두번째 입력에 연결하기를 원하므로 특별한 문법이 필요합니다. _self.connect (src0, (dst, 0))_이 바로 그것을 수행합니다: 그것은 명백하게 _src0_와 _dst_의 port 0를 연결합니다. _(dst, 0)_은 파이썬 용어로 "tuple"이라고 불립니다. 그것은 _self.connect()_를 호출할 때 port 번호를 명세 합니다. port 번호가 0일 때 block은 port 번호를 안쓸 수 있습니다. 그러므로 16번째 줄은 다음과 같이 쓸 수 있습니다.

  self.connect((src0, 0), (dst, 0))

  흐름 그래프를 만드는 모든 것을 다 했습니다. 마지막 5 줄(22번째 줄)은 흐름 그래프를 시작하는데 관련이 없습니다. 이 _try_와 _except_ 구문은 단순히 흐름 그래프가 Ctrl+C가 눌렸을 때(이것은 _KeyboardInterrupt_ 파이썬 예외를 발생합니다)  (안그랬으면 무한히 돌아갔을) 흐름 그래프가 멈춰지는 것을 확인하는 것 입니다.

  파이썬 초보자들을 위해, 두 가지 언급을 더 하지 않을 수 없습니다: 여러분은 _my\_top\_block_ 클래스가 이전에 인스턴스를 생성하지 않고 실행되었다는 것을 알아차렸을지 모르겠습니다. 파이썬에서, 특별히 여러분이 어떻게든 오직 하나의 인스턴스만을 얻으려는 클래스를 갖고 있다면 이것은 꽤 상식적인 행동입니다. 하지만, 여러분이 하나의 인스턴스를 생성하든 그 이상의 클래스 인스턴스를 생성하든 인스턴스에서 _run()_ 메소드를 호출해야 합니다.

  두번째로, 들여쓰기는 코드의 한 부분이고 C++처럼 단순히 프로그래머의 편리를 위한게 아닙니다. 여러분께서 이 코드를 실행해 보고 수정해 볼 때 탭과 스페이스를 섞어쓰지 않아야 합니다. 모든 단계는 일관적으로 들여써져야 합니다.

  여러분께서 이 튜토리얼로 계속 진행하시길 바란다면, 좀더 견고한 파이썬 지식을 먼저 얻어야 합니다. 파이썬 문서는 파이썬 웹사이트 [http://www.python.org](http://www.python.org) 또는 여러분이 선택한 라이브러리에서 찾을 수 있습니다. 이전에 프로그래밍 경험이 있던 사람들을 위한 가장 좋은 곳은 [http://wiki.python.org/moin/BeginnersGuide/Programmers](http://wiki.python.org/moin/BeginnersGuide/Programmers) 입니다.

## <a name="Summary2"></a>Summary

* 필수적인 GNU Radio 모듈들을 추가하기 위해서 _from gnuradio import_ 명령을 써야 합니다. 항상 _gr_ 모듈이 필요합니다.
* 흐름 그래프는 _gr.top\_block_으로부터 상속받은 클래스에 포함됩니다.
* 블록들은 _analog.sig\_source\_f()_와 같은 함수를 호출함으로써 그리고 변수에 반환값을 저장함으로써 생성됩니다.
* 